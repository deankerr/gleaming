---
description: Guide for structuring code in this project in modules
globs: 
alwaysApply: false
---
# Node.js Application Structure Guide

This guide outlines an approach to structuring Node.js applications that prioritizes domain boundaries and separation of concerns over traditional MVC patterns.

## 1. Structure the Application in Modules

- **Traditional MVC is insufficient** for modern Node.js applications

  - Focuses on technical responsibilities rather than domain boundaries
  - Controller files often become bloated with mixed responsibilities
  - Provides no insight about domain relationships at a glance
  - REST APIs typically don't need the View part of MVC

- **Domain-based structure is preferred**
  - Each module represents a complete slice of domain functionality
  - Contains all handlers, services, queries, and tests for that domain area
  - Makes the domain visible in the codebase structure
  - Different applications should have structures that reflect their domain

```
// 👎 Don't structure by technical responsibilities
├── src
|   ├── controllers
|   |   ├── user.js
|   |   ├── catalog.js
|   |   ├── order.js
|   ├── models
|   |   ├── user.js
|   |   ├── product.js
|   |   ├── order.js
|   ├── utils
|   |   ├── order.js
|   ├── tests
|   |   ├── user.test.js
|   |   ├── product.test.js

// 👍 Structure by domain modules
├── src
|   ├── user/                           # Everything related to users
|   |   ├── user-handlers.js            # HTTP endpoint handlers
|   |   ├── user-service.js             # Business logic
|   |   ├── user-queries.js             # Data access
|   |   ├── user-handlers.test.js
|   |   ├── index.js                    # Module's public API
|   ├── order/
|   |   ├── order-handlers.js
|   |   ├── order-service.js
|   |   ├── order-queries.js
|   |   ├── calculate-shipping.js       # Domain-specific logic
|   |   ├── calculate-shipping.test.js
|   |   ├── index.js
```

## 2. Split the Implementation in Layers

- **Avoid handler functions with too many responsibilities**

  - Handlers should not mix transport, business logic, and data access
  - Long handlers are difficult to test and maintain

- **Create layered architecture as complexity grows**

  - **Transport layer**: HTTP handlers, validation, status codes
  - **Domain layer**: Business logic in services
  - **Data layer**: Database access in queries/repositories

- **Add layers progressively**
  - Start simple with just handlers for small applications
  - Add service layer when business logic grows
  - Extract data access layer when query complexity increases

```js
// 👎 Don't create handlers with too many responsibilities
const handler = async (req, res) => {
  const { name, email } = req.body
  if (!isValidEmail(email)) {
    return res.status(400).send()
  }
  await db('users').insert({ name, email }) // Data access in handler
  if (isPromotionalPeriod()) {
    // Business logic mixed with transport concerns
    await emailService.sendPromotion(email)
  }
  return res.status(201).send()
}

// 👍 Handlers should focus on transport concerns
const handler = async (req, res) => {
  const { name, email } = req.body
  if (!isValidEmail(email)) {
    return res.status(400).send()
  }
  try {
    // Delegate to domain layer
    const user = await userService.register(name, email)
    return res.status(201).send(user)
  } catch (err) {
    return res.status(500).send()
  }
}
```

## 3. Use Services to Communicate Between Modules

- **Maintain module boundaries** by using services for inter-module communication

  - Domain modules should only modify their own data
  - Avoid direct database access across module boundaries

- **Service-based communication** enables future changes
  - Makes extraction to microservices easier
  - Allows switching implementation details without affecting consumers

```js
// 👎 Breaking module boundaries
const placeOrderHandler = (req, res) => {
  if (req.body.updateShippingAddress) {
    // Order module directly modifying user data
    db('users').where('id', req.user.id).update({ shippingAddress: req.body.shippingAddress })
  }
}

// 👍 Respect module boundaries with service calls
const placeOrderHandler = (req, res) => {
  if (req.body.updateShippingAddress) {
    // Call user service instead of direct database access
    userService.updateShippingAddress(req.user.id, req.body.shippingAddress)
  }
}
```

## 4. Separate Utility Functions and Domain Logic

- **Avoid catch-all utility folders** that mix generic functions with domain logic

  - Utilities should be truly reusable across projects
  - Domain-specific logic belongs in its domain module

- **Keep domain logic with its module**
  - Business calculations belong with their domain
  - Queries belong with the module that owns that data

```
// 👎 Mixing utilities and domain logic
├── src
|   ├── utils/
|   |   ├── capitalize.js             // Generic utility - good
|   |   ├── calculate-shipping.js     // Order domain logic - bad
|   |   ├── products-query.js         // Catalog domain logic - bad

// 👍 Proper separation
├── src
|   ├── order/
|   |   ├── calculate-shipping.js     // Domain logic with its module
|   ├── catalog/
|   |   ├── queries/
|   |   |   ├── products-query.js     // Data access with its module
|   ├── utils/
|   |   ├── capitalize.js             // Truly generic utilities
```

## Summary

- Structure your application around domain boundaries, not technical roles
- Implement layered architecture as complexity demands
- Use services to communicate between modules
- Keep domain logic with its domain, utilities truly generic
- Let your application structure tell the story of your domain
