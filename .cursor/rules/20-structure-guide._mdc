---
description: Guide for structuring code in this project in modules, use when creating or modifying modules
globs: 
alwaysApply: false
---
# The Tao of Modular Node.js Applications

## Core Principles

### Domain-Based Structure (Not Technical Roles)

Structure applications around business domains rather than technical responsibilities:

```
// ❌ MVC Structure (by technical role)
src/
  controllers/
  models/
  utils/
  tests/

// ✅ Modular Structure (by domain)
src/
  user/
    user-handlers.js
    user-service.js
    user-queries.js
    user-handlers.test.js
    index.js
  order/
    order-handlers.js
    order-service.js
    order-queries.js
    calculate-shipping.js
    index.js
```

**Why**: Your application structure should reflect what it does, not how it's built. A modular structure reveals the domain at a glance and ensures related code stays together.

### Layered Implementation Within Modules

Each module should have internal layers:

1. **Handlers** (transport layer) - HTTP/message handling
2. **Services** (business layer) - Domain logic
3. **Repositories** (data layer) - Database operations

```javascript
// Handler (focuses only on HTTP)
const handler = async (req, res) => {
  const { name, email } = req.body
  try {
    const user = await userService.register(name, email)
    return res.status(201).send(user)
  } catch (err) {
    return res.status(500).send()
  }
}

// Service (focuses on business logic)
export async function register(name, email) {
  const user = await userRepository.insert(name, email)

  if (isEligibleForPromotion()) {
    await promotionService.sendWelcomeOffer(email)
  }

  return user
}

// Repository (focuses on data access)
export async function insert(name, email) {
  return db('users').insert({ name, email })
}
```

**Start simple**: Add layers as complexity grows. Not all applications need all layers.

### Cross-Module Communication

Modules should communicate through service interfaces, not direct data access:

```javascript
// ❌ Breaking module boundaries
function placeOrder(products, userId) {
  // Order module directly accesses user data
  db('users').where('id', userId).update({ lastOrderDate: new Date() })
}

// ✅ Respecting module boundaries
function placeOrder(products, userId) {
  // Order module calls user service
  userService.updateLastOrderDate(userId)
}
```

### Domain Entities

Transform data from storage into domain entities early:

```javascript
// ❌ Leaking database details
async function getProduct(id) {
  return db.getItem(id) // Returns raw DB object with DB-specific fields
}

// ✅ Using domain entities
async function getProduct(id) {
  const dbProduct = await db.getItem(id)
  return mapToProductEntity(dbProduct) // Clean domain object
}
```

### Route Organization

Keep routes within their respective modules:

```javascript
// userModule/routes.js
const router = express.Router()
router.get('/', handlers.getProfile)
router.put('/', handlers.updateProfile)

// app.js
app.use('/api/users', userModule.routes)
app.use('/api/orders', orderModule.routes)
```

### Deep Modules with Shallow Interfaces

Create "iceberg" modules - simple interfaces hiding complex implementations:

```javascript
// ❌ Shallow module (many small functions)
export function validateUser(user) {
  /* ... */
}
export function checkEmailAvailable(email) {
  /* ... */
}
export function saveUser(user) {
  /* ... */
}
export function sendWelcomeEmail(user) {
  /* ... */
}

// ✅ Deep module (few comprehensive functions)
// Internal - hidden implementation details
function validateUser(user) {
  /* ... */
}
function checkEmailAvailable(email) {
  /* ... */
}
function saveUser(user) {
  /* ... */
}
function sendWelcomeEmail(user) {
  /* ... */
}

// Public API - simple interface
export async function registerUser(userData) {
  validateUser(userData)
  await checkEmailAvailable(userData.email)
  const user = await saveUser(userData)
  await sendWelcomeEmail(user)
  return user
}
```

## Quick Comparison: MVC vs Modular

| MVC                                        | Modular                                     |
| ------------------------------------------ | ------------------------------------------- |
| Structured by technical role               | Structured by business domain               |
| Controllers, Models, Views                 | Domain-specific modules                     |
| Logic often concentrated in controllers    | Logic distributed by domain responsibility  |
| Cross-cutting concerns spread across files | Related functionality grouped together      |
| Uniform structure across all applications  | Structure reflects specific domain problems |
| Routes typically centralized               | Routes owned by modules                     |

## When to Use This Approach

- When building non-trivial applications that model business domains
- When the application is expected to grow in complexity
- When multiple developers will work on different parts of the system
- When you want the codebase to communicate its purpose through structure

Start with simple modules and add complexity only as needed.
